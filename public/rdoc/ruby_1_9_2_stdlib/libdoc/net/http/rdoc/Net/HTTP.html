<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <!-- RD version: 0.9.5  -->
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
  <title>Class: Net::HTTPSession (Ruby 1.9.2) </title>
  <!-- raw_prefix  = '..'   -->
  <link rel="stylesheet" href="../css/obf.css" >

  <script src="../js/jquery.js" type="text/javascript" charset="utf-8"></script>
  <script src="../js/thickbox-compressed.js" type="text/javascript" charset="utf-8"></script>
  <script src="../js/quicksearch.js" type="text/javascript" charset="utf-8"></script>
  <script src="../js/rubydoc.js" type="text/javascript" charset="utf-8"></script> 

 
<script src="../js/highlight.min.js"></script>
<script> 
  hljs.tabReplace = '  ';
  hljs.initHighlightingOnLoad();
  </script> 
</head>

<body id="top" class="class">
<div id='actionbar' >
<div class='wrapper'>
<ul class='grids g0'>
  <li class='grid-2' ><a href='/' target='_top' >Home</a></li>
  <li class='grid-2' ><a href='/core' target='_top' >Core</a></li>
  <li class='grid-2' ><a href='/stdlib' target='_top' >Std-lib</a></li>
  <li class='grid-2' ><a href='/downloads' target='_top' >Downloads</a></li>
  <li class='grid-7 right' id='rd-action-search'><form id="searchbox_011815814100681837392:wnccv6st5qk" action="/search.html"><input type="hidden" name="cx" value="011815814100681837392:wnccv6st5qk" ><input name="q" type="text" size="20" >&#160;&#160;<input type="submit" name="sa" value="Search" ><input type="hidden" name="cof" value="FORID:9" ></form>
</li>
</ul>
</div>
</div> <!-- end action bar -->
          <div class='wrapper'>
  <div id="metadata">
    <div id="home-metadata">
      <div id="home-section" class="section">
        <h3 class="section-header">
          <a href="../index.html">Home</a>
          <a href="../index.html#classes">Classes</a>
          <a href="../index.html#methods">Methods</a>
        </h3>
      </div>
    </div>

    <div id="file-metadata">
      <div id="file-list-section" class="section">
        <h3 class="section-header">In Files</h3>
        <div class="section-body">
          <ul>
          
            <li><a href="../net/http_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="net/http.rb">net/http.rb</a></li>
          
          </ul>
        </div>
      </div>

      
    </div>

    <div id="class-metadata">
      
      <!-- Parent Class -->
      <div id="parent-class-section" class="section">
        <h3 class="section-header">Parent</h3>
        
        <p class="link">Protocol</p>
        
      </div>
      

      

      
      <!-- Namespace Contents -->
      <div id="namespace-list-section" class="section">
        <h3 class="section-header">Namespace</h3>
        <ul class="link-list">
          
          <li><span class="type">CLASS</span> <a href="HTTP/Copy.html">Net::HTTP::Copy</a></li>
          
          <li><span class="type">CLASS</span> <a href="HTTP/Delete.html">Net::HTTP::Delete</a></li>
          
          <li><span class="type">CLASS</span> <a href="HTTP/Get.html">Net::HTTP::Get</a></li>
          
          <li><span class="type">CLASS</span> <a href="HTTP/Head.html">Net::HTTP::Head</a></li>
          
          <li><span class="type">CLASS</span> <a href="HTTP/Lock.html">Net::HTTP::Lock</a></li>
          
          <li><span class="type">CLASS</span> <a href="HTTP/Mkcol.html">Net::HTTP::Mkcol</a></li>
          
          <li><span class="type">CLASS</span> <a href="HTTP/Move.html">Net::HTTP::Move</a></li>
          
          <li><span class="type">CLASS</span> <a href="HTTP/Options.html">Net::HTTP::Options</a></li>
          
          <li><span class="type">CLASS</span> <a href="HTTP/Post.html">Net::HTTP::Post</a></li>
          
          <li><span class="type">CLASS</span> <a href="HTTP/Propfind.html">Net::HTTP::Propfind</a></li>
          
          <li><span class="type">CLASS</span> <a href="HTTP/Proppatch.html">Net::HTTP::Proppatch</a></li>
          
          <li><span class="type">CLASS</span> <a href="HTTP/Put.html">Net::HTTP::Put</a></li>
          
          <li><span class="type">CLASS</span> <a href="HTTP/Trace.html">Net::HTTP::Trace</a></li>
          
          <li><span class="type">CLASS</span> <a href="HTTP/Unlock.html">Net::HTTP::Unlock</a></li>
          
        </ul>
      </div>
      

      
      <!-- Method Quickref -->
      <div id="method-list-section" class="section">
        <h3 class="section-header">Methods</h3>
        <ul class="link-list">
          
          <li><a href="#method-c-Proxy">::Proxy</a></li>
          
          <li><a href="#method-c-default_port">::default_port</a></li>
          
          <li><a href="#method-c-get">::get</a></li>
          
          <li><a href="#method-c-get_print">::get_print</a></li>
          
          <li><a href="#method-c-get_response">::get_response</a></li>
          
          <li><a href="#method-c-http_default_port">::http_default_port</a></li>
          
          <li><a href="#method-c-https_default_port">::https_default_port</a></li>
          
          <li><a href="#method-c-is_version_1_1-3F">::is_version_1_1?</a></li>
          
          <li><a href="#method-c-is_version_1_2-3F">::is_version_1_2?</a></li>
          
          <li><a href="#method-c-new">::new</a></li>
          
          <li><a href="#method-c-new">::new</a></li>
          
          <li><a href="#method-c-newobj">::newobj</a></li>
          
          <li><a href="#method-c-post_form">::post_form</a></li>
          
          <li><a href="#method-c-proxy_class-3F">::proxy_class?</a></li>
          
          <li><a href="#method-c-start">::start</a></li>
          
          <li><a href="#method-c-version_1_1">::version_1_1</a></li>
          
          <li><a href="#method-c-version_1_1-3F">::version_1_1?</a></li>
          
          <li><a href="#method-c-version_1_2">::version_1_2</a></li>
          
          <li><a href="#method-c-version_1_2-3F">::version_1_2?</a></li>
          
          <li><a href="#method-i-active-3F">#active?</a></li>
          
          <li><a href="#method-i-copy">#copy</a></li>
          
          <li><a href="#method-i-delete">#delete</a></li>
          
          <li><a href="#method-i-finish">#finish</a></li>
          
          <li><a href="#method-i-get">#get</a></li>
          
          <li><a href="#method-i-get2">#get2</a></li>
          
          <li><a href="#method-i-head">#head</a></li>
          
          <li><a href="#method-i-head2">#head2</a></li>
          
          <li><a href="#method-i-inspect">#inspect</a></li>
          
          <li><a href="#method-i-lock">#lock</a></li>
          
          <li><a href="#method-i-mkcol">#mkcol</a></li>
          
          <li><a href="#method-i-move">#move</a></li>
          
          <li><a href="#method-i-options">#options</a></li>
          
          <li><a href="#method-i-peer_cert">#peer_cert</a></li>
          
          <li><a href="#method-i-post">#post</a></li>
          
          <li><a href="#method-i-post2">#post2</a></li>
          
          <li><a href="#method-i-propfind">#propfind</a></li>
          
          <li><a href="#method-i-proppatch">#proppatch</a></li>
          
          <li><a href="#method-i-proxy-3F">#proxy?</a></li>
          
          <li><a href="#method-i-proxy_address">#proxy_address</a></li>
          
          <li><a href="#method-i-proxy_pass">#proxy_pass</a></li>
          
          <li><a href="#method-i-proxy_port">#proxy_port</a></li>
          
          <li><a href="#method-i-proxy_user">#proxy_user</a></li>
          
          <li><a href="#method-i-proxyaddr">#proxyaddr</a></li>
          
          <li><a href="#method-i-proxyport">#proxyport</a></li>
          
          <li><a href="#method-i-read_timeout-3D">#read_timeout=</a></li>
          
          <li><a href="#method-i-request">#request</a></li>
          
          <li><a href="#method-i-request_get">#request_get</a></li>
          
          <li><a href="#method-i-request_head">#request_head</a></li>
          
          <li><a href="#method-i-request_post">#request_post</a></li>
          
          <li><a href="#method-i-send_request">#send_request</a></li>
          
          <li><a href="#method-i-set_debug_output">#set_debug_output</a></li>
          
          <li><a href="#method-i-start">#start</a></li>
          
          <li><a href="#method-i-started-3F">#started?</a></li>
          
          <li><a href="#method-i-trace">#trace</a></li>
          
          <li><a href="#method-i-unlock">#unlock</a></li>
          
          <li><a href="#method-i-use_ssl-3D">#use_ssl=</a></li>
          
          <li><a href="#method-i-use_ssl-3F">#use_ssl?</a></li>
          
        </ul>
      </div>
      

      
    </div>

    <div id="project-metadata">
      
      

      <div id="classindex-section" class="section project-section">
        <h3 class="section-header">Class/Module Index
          <span class="search-toggle"><img src="../images/find.png"
            height="16" width="16" alt="[+]"
            title="show/hide quicksearch" /></span></h3>
        <form action="#" method="get" accept-charset="utf-8" class="initially-hidden">
        <fieldset>
          <legend>Quicksearch</legend>
          <input type="text" name="quicksearch" value=""
            class="quicksearch-field" />
        </fieldset>
        </form>

        <ul class="link-list">
        
          <li><a href="../Net.html">Net</a></li>
        
          <li><a href="../Net/HTTP.html">Net::HTTP</a></li>
        
          <li><a href="../Net/HTTP/Copy.html">Net::HTTP::Copy</a></li>
        
          <li><a href="../Net/HTTP/Delete.html">Net::HTTP::Delete</a></li>
        
          <li><a href="../Net/HTTP/Get.html">Net::HTTP::Get</a></li>
        
          <li><a href="../Net/HTTP/Head.html">Net::HTTP::Head</a></li>
        
          <li><a href="../Net/HTTP/Lock.html">Net::HTTP::Lock</a></li>
        
          <li><a href="../Net/HTTP/Mkcol.html">Net::HTTP::Mkcol</a></li>
        
          <li><a href="../Net/HTTP/Move.html">Net::HTTP::Move</a></li>
        
          <li><a href="../Net/HTTP/Options.html">Net::HTTP::Options</a></li>
        
          <li><a href="../Net/HTTP/Post.html">Net::HTTP::Post</a></li>
        
          <li><a href="../Net/HTTP/Propfind.html">Net::HTTP::Propfind</a></li>
        
          <li><a href="../Net/HTTP/Proppatch.html">Net::HTTP::Proppatch</a></li>
        
          <li><a href="../Net/HTTP/Put.html">Net::HTTP::Put</a></li>
        
          <li><a href="../Net/HTTP/Trace.html">Net::HTTP::Trace</a></li>
        
          <li><a href="../Net/HTTP/Unlock.html">Net::HTTP::Unlock</a></li>
        
          <li><a href="../Net/HTTPAccepted.html">Net::HTTPAccepted</a></li>
        
          <li><a href="../Net/HTTPBadGateway.html">Net::HTTPBadGateway</a></li>
        
          <li><a href="../Net/HTTPBadRequest.html">Net::HTTPBadRequest</a></li>
        
          <li><a href="../Net/HTTPBadResponse.html">Net::HTTPBadResponse</a></li>
        
          <li><a href="../Net/HTTPClientError.html">Net::HTTPClientError</a></li>
        
          <li><a href="../Net/HTTPConflict.html">Net::HTTPConflict</a></li>
        
          <li><a href="../Net/HTTPContinue.html">Net::HTTPContinue</a></li>
        
          <li><a href="../Net/HTTPCreated.html">Net::HTTPCreated</a></li>
        
          <li><a href="../Net/HTTPError.html">Net::HTTPError</a></li>
        
          <li><a href="../Net/HTTPError.html">Net::HTTPError</a></li>
        
          <li><a href="../Net/HTTPError.html">Net::HTTPError</a></li>
        
          <li><a href="../Net/HTTPError.html">Net::HTTPError</a></li>
        
          <li><a href="../Net/HTTPExceptions.html">Net::HTTPExceptions</a></li>
        
          <li><a href="../Net/HTTPExpectationFailed.html">Net::HTTPExpectationFailed</a></li>
        
          <li><a href="../Net/HTTPFatalError.html">Net::HTTPFatalError</a></li>
        
          <li><a href="../Net/HTTPForbidden.html">Net::HTTPForbidden</a></li>
        
          <li><a href="../Net/HTTPFound.html">Net::HTTPFound</a></li>
        
          <li><a href="../Net/HTTPFound.html">Net::HTTPFound</a></li>
        
          <li><a href="../Net/HTTPGatewayTimeOut.html">Net::HTTPGatewayTimeOut</a></li>
        
          <li><a href="../Net/HTTPGenericRequest.html">Net::HTTPGenericRequest</a></li>
        
          <li><a href="../Net/HTTPGone.html">Net::HTTPGone</a></li>
        
          <li><a href="../Net/HTTPHeader.html">Net::HTTPHeader</a></li>
        
          <li><a href="../Net/HTTPHeaderSyntaxError.html">Net::HTTPHeaderSyntaxError</a></li>
        
          <li><a href="../Net/HTTPInformation.html">Net::HTTPInformation</a></li>
        
          <li><a href="../Net/HTTPInternalServerError.html">Net::HTTPInternalServerError</a></li>
        
          <li><a href="../Net/HTTPLengthRequired.html">Net::HTTPLengthRequired</a></li>
        
          <li><a href="../Net/HTTPMethodNotAllowed.html">Net::HTTPMethodNotAllowed</a></li>
        
          <li><a href="../Net/HTTPMovedPermanently.html">Net::HTTPMovedPermanently</a></li>
        
          <li><a href="../Net/HTTPMultipleChoice.html">Net::HTTPMultipleChoice</a></li>
        
          <li><a href="../Net/HTTPNoContent.html">Net::HTTPNoContent</a></li>
        
          <li><a href="../Net/HTTPNonAuthoritativeInformation.html">Net::HTTPNonAuthoritativeInformation</a></li>
        
          <li><a href="../Net/HTTPNotAcceptable.html">Net::HTTPNotAcceptable</a></li>
        
          <li><a href="../Net/HTTPNotFound.html">Net::HTTPNotFound</a></li>
        
          <li><a href="../Net/HTTPNotImplemented.html">Net::HTTPNotImplemented</a></li>
        
          <li><a href="../Net/HTTPNotModified.html">Net::HTTPNotModified</a></li>
        
          <li><a href="../Net/HTTPOK.html">Net::HTTPOK</a></li>
        
          <li><a href="../Net/HTTPPartialContent.html">Net::HTTPPartialContent</a></li>
        
          <li><a href="../Net/HTTPPaymentRequired.html">Net::HTTPPaymentRequired</a></li>
        
          <li><a href="../Net/HTTPPreconditionFailed.html">Net::HTTPPreconditionFailed</a></li>
        
          <li><a href="../Net/HTTPProxyAuthenticationRequired.html">Net::HTTPProxyAuthenticationRequired</a></li>
        
          <li><a href="../Net/HTTPRedirection.html">Net::HTTPRedirection</a></li>
        
          <li><a href="../Net/HTTPRequest.html">Net::HTTPRequest</a></li>
        
          <li><a href="../Net/HTTPRequestEntityTooLarge.html">Net::HTTPRequestEntityTooLarge</a></li>
        
          <li><a href="../Net/HTTPRequestTimeOut.html">Net::HTTPRequestTimeOut</a></li>
        
          <li><a href="../Net/HTTPRequestURITooLong.html">Net::HTTPRequestURITooLong</a></li>
        
          <li><a href="../Net/HTTPRequestURITooLong.html">Net::HTTPRequestURITooLong</a></li>
        
          <li><a href="../Net/HTTPRequestedRangeNotSatisfiable.html">Net::HTTPRequestedRangeNotSatisfiable</a></li>
        
          <li><a href="../Net/HTTPResetContent.html">Net::HTTPResetContent</a></li>
        
          <li><a href="../Net/HTTPResponse.html">Net::HTTPResponse</a></li>
        
          <li><a href="../Net/HTTPRetriableError.html">Net::HTTPRetriableError</a></li>
        
          <li><a href="../Net/HTTPRetriableError.html">Net::HTTPRetriableError</a></li>
        
          <li><a href="../Net/HTTPSeeOther.html">Net::HTTPSeeOther</a></li>
        
          <li><a href="../Net/HTTPServerError.html">Net::HTTPServerError</a></li>
        
          <li><a href="../Net/HTTPServerException.html">Net::HTTPServerException</a></li>
        
          <li><a href="../Net/HTTPServiceUnavailable.html">Net::HTTPServiceUnavailable</a></li>
        
          <li><a href="../Net/HTTP.html">Net::HTTPSession</a></li>
        
          <li><a href="../Net/HTTPSuccess.html">Net::HTTPSuccess</a></li>
        
          <li><a href="../Net/HTTPSwitchProtocol.html">Net::HTTPSwitchProtocol</a></li>
        
          <li><a href="../Net/HTTPTemporaryRedirect.html">Net::HTTPTemporaryRedirect</a></li>
        
          <li><a href="../Net/HTTPUnauthorized.html">Net::HTTPUnauthorized</a></li>
        
          <li><a href="../Net/HTTPUnknownResponse.html">Net::HTTPUnknownResponse</a></li>
        
          <li><a href="../Net/HTTPUnsupportedMediaType.html">Net::HTTPUnsupportedMediaType</a></li>
        
          <li><a href="../Net/HTTPUseProxy.html">Net::HTTPUseProxy</a></li>
        
          <li><a href="../Net/HTTPVersionNotSupported.html">Net::HTTPVersionNotSupported</a></li>
        
        </ul>
        <div id="no-class-search-results" style="display: none;">No matching classes.</div>
      </div>

      
    </div>
  </div>

  <div id="documentation">
    <h1 class="class">Net::HTTPSession</h1>

    <div id="description" class="description">
      
<h2>What Is This Library?</h2>

<p>This library provides your program functions to access WWW documents via
HTTP, Hyper Text Transfer Protocol version 1.1. For details of HTTP, refer
to [RFC2616] (<a
href="http://www.ietf.org/rfc/rfc2616.txt">www.ietf.org/rfc/rfc2616.txt</a>).</p>

<h2>Examples</h2>

<h3>Getting Document From WWW Server</h3>

<p>Example #1: Simple GET+print</p>

<pre>require 'net/http'
Net::HTTP.get_print 'www.example.com', '/index.html'</pre>

<p>Example #2: Simple GET+print by URL</p>

<pre>require 'net/http'
require 'uri'
Net::HTTP.get_print URI.parse('http://www.example.com/index.html')</pre>

<p>Example #3: More generic GET+print</p>

<pre>require 'net/http'
require 'uri'

url = URI.parse('http://www.example.com/index.html')
res = Net::HTTP.start(url.host, url.port) {|http|
  http.get('/index.html')
}
puts res.body</pre>

<p>Example #4: More generic GET+print</p>

<pre>require 'net/http'

url = URI.parse('http://www.example.com/index.html')
req = Net::HTTP::Get.new(url.path)
res = Net::HTTP.start(url.host, url.port) {|http|
  http.request(req)
}
puts res.body</pre>

<h3>Posting Form Data</h3>

<pre>require 'net/http'
require 'uri'

#1: Simple POST
res = Net::HTTP.post_form(URI.parse('http://www.example.com/search.cgi'),
                          {'q' =&gt; 'ruby', 'max' =&gt; '50'})
puts res.body

#2: POST with basic authentication
res = Net::HTTP.post_form(URI.parse('http://jack:pass@www.example.com/todo.cgi'),
                                    {'from' =&gt; '2005-01-01',
                                     'to' =&gt; '2005-03-31'})
puts res.body

#3: Detailed control
url = URI.parse('http://www.example.com/todo.cgi')
req = Net::HTTP::Post.new(url.path)
req.basic_auth 'jack', 'pass'
req.set_form_data({'from' =&gt; '2005-01-01', 'to' =&gt; '2005-03-31'}, ';')
res = Net::HTTP.new(url.host, url.port).start {|http| http.request(req) }
case res
when Net::HTTPSuccess, Net::HTTPRedirection
  # OK
else
  res.error!
end

#4: Multiple values
res = Net::HTTP.post_form(URI.parse('http://www.example.com/search.cgi'),
                          {'q' =&gt; ['ruby', 'perl'], 'max' =&gt; '50'})
puts res.body</pre>

<h3>Accessing via <a href="HTTP.html#method-c-Proxy">Proxy</a></h3>

<p>Net::HTTP.<a href="HTTP.html#method-c-Proxy">Proxy</a> creates http proxy
class. It has same methods of Net::HTTP but its instances always connect to
proxy, instead of given host.</p>

<pre>require 'net/http'

proxy_addr = 'your.proxy.host'
proxy_port = 8080
        :
Net::HTTP::Proxy(proxy_addr, proxy_port).start('www.example.com') {|http|
  # always connect to your.proxy.addr:8080
        :
}</pre>

<p>Since Net::HTTP.<a href="HTTP.html#method-c-Proxy">Proxy</a> returns
Net::HTTP itself when proxy_addr is nil, there’s no need to change code if
there’s proxy or not.</p>

<p>There are two additional parameters in Net::HTTP.<a
href="HTTP.html#method-c-Proxy">Proxy</a> which allow to specify proxy user
name and password:</p>

<pre>Net::HTTP::Proxy(proxy_addr, proxy_port, proxy_user = nil, proxy_pass = nil)</pre>

<p>You may use them to work with authorization-enabled proxies:</p>

<pre>require 'net/http'
require 'uri'

proxy_host = 'your.proxy.host'
proxy_port = 8080
uri = URI.parse(ENV['http_proxy'])
proxy_user, proxy_pass = uri.userinfo.split(/:/) if uri.userinfo
Net::HTTP::Proxy(proxy_host, proxy_port,
                 proxy_user, proxy_pass).start('www.example.com') {|http|
  # always connect to your.proxy.addr:8080 using specified username and password
        :
}</pre>

<p>Note that net/http never rely on HTTP_PROXY environment variable. If you
want to use proxy, set it explicitly.</p>

<h3>Following Redirection</h3>

<pre>require 'net/http'
require 'uri'

def fetch(uri_str, limit = 10)
  # You should choose better exception.
  raise ArgumentError, 'HTTP redirect too deep' if limit == 0

  response = Net::HTTP.get_response(URI.parse(uri_str))
  case response
  when Net::HTTPSuccess     then response
  when Net::HTTPRedirection then fetch(response['location'], limit - 1)
  else
    response.error!
  end
end

print fetch('http://www.ruby-lang.org')</pre>

<p>Net::HTTPSuccess and Net::HTTPRedirection is a <a
href="HTTPResponse.html">HTTPResponse</a> class. All <a
href="HTTPResponse.html">HTTPResponse</a> objects belong to its own
response class which indicate HTTP result status. For details of response
classes, see section “HTTP Response Classes”.</p>

<h3>Basic Authentication</h3>

<pre>require 'net/http'

Net::HTTP.start('www.example.com') {|http|
  req = Net::HTTP::Get.new('/secret-page.html')
  req.basic_auth 'account', 'password'
  response = http.request(req)
  print response.body
}</pre>

<h3>HTTP Request Classes</h3>

<p>Here is HTTP request class hierarchy.</p>

<pre>Net::HTTPRequest
    Net::HTTP::Get
    Net::HTTP::Head
    Net::HTTP::Post
    Net::HTTP::Put
    Net::HTTP::Proppatch
    Net::HTTP::Lock
    Net::HTTP::Unlock
    Net::HTTP::Options
    Net::HTTP::Propfind
    Net::HTTP::Delete
    Net::HTTP::Move
    Net::HTTP::Copy
    Net::HTTP::Mkcol
    Net::HTTP::Trace</pre>

<h3>HTTP Response Classes</h3>

<p>Here is HTTP response class hierarchy. All classes are defined in <a
href="../Net.html">Net</a> module.</p>

<pre>HTTPResponse
    HTTPUnknownResponse
    HTTPInformation                    # 1xx
        HTTPContinue                       # 100
        HTTPSwitchProtocol                 # 101
    HTTPSuccess                        # 2xx
        HTTPOK                             # 200
        HTTPCreated                        # 201
        HTTPAccepted                       # 202
        HTTPNonAuthoritativeInformation    # 203
        HTTPNoContent                      # 204
        HTTPResetContent                   # 205
        HTTPPartialContent                 # 206
    HTTPRedirection                    # 3xx
        HTTPMultipleChoice                 # 300
        HTTPMovedPermanently               # 301
        HTTPFound                          # 302
        HTTPSeeOther                       # 303
        HTTPNotModified                    # 304
        HTTPUseProxy                       # 305
        HTTPTemporaryRedirect              # 307
    HTTPClientError                    # 4xx
        HTTPBadRequest                     # 400
        HTTPUnauthorized                   # 401
        HTTPPaymentRequired                # 402
        HTTPForbidden                      # 403
        HTTPNotFound                       # 404
        HTTPMethodNotAllowed               # 405
        HTTPNotAcceptable                  # 406
        HTTPProxyAuthenticationRequired    # 407
        HTTPRequestTimeOut                 # 408
        HTTPConflict                       # 409
        HTTPGone                           # 410
        HTTPLengthRequired                 # 411
        HTTPPreconditionFailed             # 412
        HTTPRequestEntityTooLarge          # 413
        HTTPRequestURITooLong              # 414
        HTTPUnsupportedMediaType           # 415
        HTTPRequestedRangeNotSatisfiable   # 416
        HTTPExpectationFailed              # 417
    HTTPServerError                    # 5xx
        HTTPInternalServerError            # 500
        HTTPNotImplemented                 # 501
        HTTPBadGateway                     # 502
        HTTPServiceUnavailable             # 503
        HTTPGatewayTimeOut                 # 504
        HTTPVersionNotSupported            # 505</pre>

<h2>Switching Net::HTTP versions</h2>

<p>You can use <a href="../net/http_rb.html">net/http.rb</a> 1.1 features
(bundled with Ruby 1.6) by calling <a
href="HTTP.html#method-c-version_1_1">HTTP.version_1_1</a>. Calling <a
href="HTTP.html#method-c-version_1_2">Net::HTTP.version_1_2</a> allows you
to use 1.2 features again.</p>

<pre># example
Net::HTTP.start {|http1| ...(http1 has 1.2 features)... }

Net::HTTP.version_1_1
Net::HTTP.start {|http2| ...(http2 has 1.1 features)... }

Net::HTTP.version_1_2
Net::HTTP.start {|http3| ...(http3 has 1.2 features)... }</pre>

<p>This function is NOT thread-safe.</p>

    </div><!-- description -->

    
    
    
    <div id="5Buntitled-5D" class="documentation-section">
      

      

      
      <!-- Constants -->
      <div id="constants-list" class="section">
        <h3 class="section-header">Constants</h3>
        <dl>
        
          <dt><a name="SSL_ATTRIBUTES">SSL_ATTRIBUTES</a></dt>
          
          <dd class="description"></dd>
          
        
        </dl>
      </div>
      

      
      <!-- Attributes -->
      <div id="attribute-method-details" class="method-section section">
        <h3 class="section-header">Attributes</h3>

        
        <div id="proxy_address-attribute-method" class="method-detail">
          <a name="proxy_address"></a>
          
          <div class="method-heading attribute-method-heading">
            <span class="method-name">proxy_address</span><span
              class="attribute-access-type">[R]</span>
          </div>

          <div class="method-description">
          
          
          
          </div>
        </div>
        
        <div id="proxy_pass-attribute-method" class="method-detail">
          <a name="proxy_pass"></a>
          
          <div class="method-heading attribute-method-heading">
            <span class="method-name">proxy_pass</span><span
              class="attribute-access-type">[R]</span>
          </div>

          <div class="method-description">
          
          
          
          </div>
        </div>
        
        <div id="proxy_port-attribute-method" class="method-detail">
          <a name="proxy_port"></a>
          
          <div class="method-heading attribute-method-heading">
            <span class="method-name">proxy_port</span><span
              class="attribute-access-type">[R]</span>
          </div>

          <div class="method-description">
          
          
          
          </div>
        </div>
        
        <div id="proxy_user-attribute-method" class="method-detail">
          <a name="proxy_user"></a>
          
          <div class="method-heading attribute-method-heading">
            <span class="method-name">proxy_user</span><span
              class="attribute-access-type">[R]</span>
          </div>

          <div class="method-description">
          
          
          
          </div>
        </div>
        
        <div id="address-attribute-method" class="method-detail">
          <a name="address"></a>
          
          <div class="method-heading attribute-method-heading">
            <span class="method-name">address</span><span
              class="attribute-access-type">[R]</span>
          </div>

          <div class="method-description">
          
          <p>The host name to connect to.</p>
          
          </div>
        </div>
        
        <div id="close_on_empty_response-attribute-method" class="method-detail">
          <a name="close_on_empty_response"></a>
          
          <a name="close_on_empty_response="></a>
          
          <div class="method-heading attribute-method-heading">
            <span class="method-name">close_on_empty_response</span><span
              class="attribute-access-type">[RW]</span>
          </div>

          <div class="method-description">
          
          
          
          </div>
        </div>
        
        <div id="open_timeout-attribute-method" class="method-detail">
          <a name="open_timeout"></a>
          
          <a name="open_timeout="></a>
          
          <div class="method-heading attribute-method-heading">
            <span class="method-name">open_timeout</span><span
              class="attribute-access-type">[RW]</span>
          </div>

          <div class="method-description">
          
          <p>Seconds to wait until connection is opened. If the HTTP object cannot open
a connection in this many seconds, it raises a TimeoutError exception.</p>
          
          </div>
        </div>
        
        <div id="port-attribute-method" class="method-detail">
          <a name="port"></a>
          
          <div class="method-heading attribute-method-heading">
            <span class="method-name">port</span><span
              class="attribute-access-type">[R]</span>
          </div>

          <div class="method-description">
          
          <p>The port number to connect to.</p>
          
          </div>
        </div>
        
        <div id="read_timeout-attribute-method" class="method-detail">
          <a name="read_timeout"></a>
          
          <div class="method-heading attribute-method-heading">
            <span class="method-name">read_timeout</span><span
              class="attribute-access-type">[R]</span>
          </div>

          <div class="method-description">
          
          <p>Seconds to wait until reading one block (by one read(2) call). If the HTTP
object cannot open a connection in this many seconds, it raises a
TimeoutError exception.</p>
          
          </div>
        </div>
        
      </div><!-- attribute-method-details -->
      

      <!-- Methods -->
      
      <div id="public-class-method-details" class="method-section section">
        <h3 class="section-header">Public Class Methods</h3>

      
        <div id="Proxy-method" class="method-detail ">
          <a name="method-c-Proxy"></a>

          
          <div class="method-heading">
            <span class="method-name">Proxy</span><span
              class="method-args">(p_addr, p_port = nil, p_user = nil, p_pass = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Creates an HTTP proxy class. Arguments are address/port of proxy host and
username/password if authorization on proxy server is required. You can
replace the HTTP class with created proxy class.</p>

<p>If ADDRESS is nil, this method returns self (Net::HTTP).</p>

<pre># Example
proxy_class = Net::HTTP::Proxy('proxy.example.com', 8080)
                :
proxy_class.start('www.ruby-lang.org') {|http|
  # connecting proxy.foo.org:8080
                :
}</pre>
            

            
            <div class="method-source-code" id="Proxy-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 738</span>
<span class="ruby-keyword">def</span> <span class="ruby-constant">HTTP</span>.<span class="ruby-constant">Proxy</span>(<span class="ruby-identifier">p_addr</span>, <span class="ruby-identifier">p_port</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">p_user</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">p_pass</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">self</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">p_addr</span>
  <span class="ruby-identifier">delta</span> = <span class="ruby-constant">ProxyDelta</span>
  <span class="ruby-identifier">proxyclass</span> = <span class="ruby-constant">Class</span>.<span class="ruby-identifier">new</span>(<span class="ruby-keyword">self</span>)
  <span class="ruby-identifier">proxyclass</span>.<span class="ruby-identifier">module_eval</span> {
    <span class="ruby-identifier">include</span> <span class="ruby-identifier">delta</span>
    <span class="ruby-comment"># with proxy</span>
    <span class="ruby-ivar">@is_proxy_class</span> = <span class="ruby-keyword">true</span>
    <span class="ruby-ivar">@proxy_address</span> = <span class="ruby-identifier">p_addr</span>
    <span class="ruby-ivar">@proxy_port</span>    = <span class="ruby-identifier">p_port</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">default_port</span>()
    <span class="ruby-ivar">@proxy_user</span>    = <span class="ruby-identifier">p_user</span>
    <span class="ruby-ivar">@proxy_pass</span>    = <span class="ruby-identifier">p_pass</span>
  }
  <span class="ruby-identifier">proxyclass</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- Proxy-source -->
            
          </div>

          

          
        </div><!-- Proxy-method -->

      
        <div id="default_port-method" class="method-detail ">
          <a name="method-c-default_port"></a>

          
          <div class="method-heading">
            <span class="method-name">default_port</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>The default port to use for HTTP requests; defaults to 80.</p>
            

            
            <div class="method-source-code" id="default_port-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 428</span>
<span class="ruby-keyword">def</span> <span class="ruby-constant">HTTP</span>.<span class="ruby-identifier">default_port</span>
  <span class="ruby-identifier">http_default_port</span>()
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- default_port-source -->
            
          </div>

          

          
        </div><!-- default_port-method -->

      
        <div id="get-method" class="method-detail ">
          <a name="method-c-get"></a>

          
          <div class="method-heading">
            <span class="method-name">get</span><span
              class="method-args">(uri_or_host, path = nil, port = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Send a GET request to the target and return the response as a string.  The
target can either be specified as (<tt>uri</tt>), or as (<tt>host</tt>,
<tt>path</tt>, <tt>port</tt> = 80); so:</p>

<pre>print Net::HTTP.get(URI.parse('http://www.example.com/index.html'))</pre>

<p>or:</p>

<pre>print Net::HTTP.get('www.example.com', '/index.html')</pre>
            

            
            <div class="method-source-code" id="get-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 369</span>
<span class="ruby-keyword">def</span> <span class="ruby-constant">HTTP</span>.<span class="ruby-identifier">get</span>(<span class="ruby-identifier">uri_or_host</span>, <span class="ruby-identifier">path</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">port</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">get_response</span>(<span class="ruby-identifier">uri_or_host</span>, <span class="ruby-identifier">path</span>, <span class="ruby-identifier">port</span>).<span class="ruby-identifier">body</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- get-source -->
            
          </div>

          

          
        </div><!-- get-method -->

      
        <div id="get_print-method" class="method-detail ">
          <a name="method-c-get_print"></a>

          
          <div class="method-heading">
            <span class="method-name">get_print</span><span
              class="method-args">(uri_or_host, path = nil, port = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p><a href="HTTP/Get.html">Get</a> body from target and output it to
+$stdout+.  The target can either be specified as (<tt>uri</tt>), or as
(<tt>host</tt>, <tt>path</tt>, <tt>port</tt> = 80); so:</p>

<pre>Net::HTTP.get_print URI.parse('http://www.example.com/index.html')</pre>

<p>or:</p>

<pre>Net::HTTP.get_print 'www.example.com', '/index.html'</pre>
            

            
            <div class="method-source-code" id="get_print-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 350</span>
<span class="ruby-keyword">def</span> <span class="ruby-constant">HTTP</span>.<span class="ruby-identifier">get_print</span>(<span class="ruby-identifier">uri_or_host</span>, <span class="ruby-identifier">path</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">port</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">get_response</span>(<span class="ruby-identifier">uri_or_host</span>, <span class="ruby-identifier">path</span>, <span class="ruby-identifier">port</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">res</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">res</span>.<span class="ruby-identifier">read_body</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">chunk</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">$stdout</span>.<span class="ruby-identifier">print</span> <span class="ruby-identifier">chunk</span>
    <span class="ruby-keyword">end</span>
  }
  <span class="ruby-keyword">nil</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- get_print-source -->
            
          </div>

          

          
        </div><!-- get_print-method -->

      
        <div id="get_response-method" class="method-detail ">
          <a name="method-c-get_response"></a>

          
          <div class="method-heading">
            <span class="method-name">get_response</span><span
              class="method-args">(uri_or_host, path = nil, port = nil, &block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Send a GET request to the target and return the response as a <a
href="HTTPResponse.html">Net::HTTPResponse</a> object.  The target can
either be specified as (<tt>uri</tt>), or as (<tt>host</tt>, <tt>path</tt>,
<tt>port</tt> = 80); so:</p>

<pre>res = Net::HTTP.get_response(URI.parse('http://www.example.com/index.html'))
print res.body</pre>

<p>or:</p>

<pre>res = Net::HTTP.get_response('www.example.com', '/index.html')
print res.body</pre>
            

            
            <div class="method-source-code" id="get_response-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 385</span>
<span class="ruby-keyword">def</span> <span class="ruby-constant">HTTP</span>.<span class="ruby-identifier">get_response</span>(<span class="ruby-identifier">uri_or_host</span>, <span class="ruby-identifier">path</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">port</span> = <span class="ruby-keyword">nil</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">path</span>
    <span class="ruby-identifier">host</span> = <span class="ruby-identifier">uri_or_host</span>
    <span class="ruby-identifier">new</span>(<span class="ruby-identifier">host</span>, <span class="ruby-identifier">port</span> <span class="ruby-operator">||</span> <span class="ruby-constant">HTTP</span>.<span class="ruby-identifier">default_port</span>).<span class="ruby-identifier">start</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">http</span><span class="ruby-operator">|</span>
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">http</span>.<span class="ruby-identifier">request_get</span>(<span class="ruby-identifier">path</span>, &amp;<span class="ruby-identifier">block</span>)
    }
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">uri</span> = <span class="ruby-identifier">uri_or_host</span>
    <span class="ruby-identifier">new</span>(<span class="ruby-identifier">uri</span>.<span class="ruby-identifier">host</span>, <span class="ruby-identifier">uri</span>.<span class="ruby-identifier">port</span>).<span class="ruby-identifier">start</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">http</span><span class="ruby-operator">|</span>
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">http</span>.<span class="ruby-identifier">request_get</span>(<span class="ruby-identifier">uri</span>.<span class="ruby-identifier">request_uri</span>, &amp;<span class="ruby-identifier">block</span>)
    }
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- get_response-source -->
            
          </div>

          

          
        </div><!-- get_response-method -->

      
        <div id="http_default_port-method" class="method-detail ">
          <a name="method-c-http_default_port"></a>

          
          <div class="method-heading">
            <span class="method-name">http_default_port</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>The default port to use for HTTP requests; defaults to 80.</p>
            

            
            <div class="method-source-code" id="http_default_port-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 433</span>
<span class="ruby-keyword">def</span> <span class="ruby-constant">HTTP</span>.<span class="ruby-identifier">http_default_port</span>
  <span class="ruby-value">80</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- http_default_port-source -->
            
          </div>

          

          
        </div><!-- http_default_port-method -->

      
        <div id="https_default_port-method" class="method-detail ">
          <a name="method-c-https_default_port"></a>

          
          <div class="method-heading">
            <span class="method-name">https_default_port</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>The default port to use for HTTPS requests; defaults to 443.</p>
            

            
            <div class="method-source-code" id="https_default_port-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 438</span>
<span class="ruby-keyword">def</span> <span class="ruby-constant">HTTP</span>.<span class="ruby-identifier">https_default_port</span>
  <span class="ruby-value">443</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- https_default_port-source -->
            
          </div>

          

          
        </div><!-- https_default_port-method -->

      
        <div id="is_version_1_1-3F-method" class="method-detail method-alias">
          <a name="method-c-is_version_1_1-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">is_version_1_1?</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
          </div>

          

          
          <div class="aliases">
            Alias for: <a href="HTTP.html#method-c-version_1_1-3F">version_1_1?</a>
          </div>
          
        </div><!-- is_version_1_1-3F-method -->

      
        <div id="is_version_1_2-3F-method" class="method-detail method-alias">
          <a name="method-c-is_version_1_2-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">is_version_1_2?</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
          </div>

          

          
          <div class="aliases">
            Alias for: <a href="HTTP.html#method-c-version_1_2-3F">version_1_2?</a>
          </div>
          
        </div><!-- is_version_1_2-3F-method -->

      
        <div id="new-method" class="method-detail ">
          <a name="method-c-new"></a>

          
          <div class="method-heading">
            <span class="method-name">new</span><span
              class="method-args">(address, port = nil, p_addr = nil, p_port = nil, p_user = nil, p_pass = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Creates a new Net::HTTP object. If <tt>proxy_addr</tt> is given, creates an
Net::HTTP object with proxy support. This method does not open the TCP
connection.</p>
            

            
            <div class="method-source-code" id="new-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 500</span>
<span class="ruby-keyword">def</span> <span class="ruby-constant">HTTP</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">address</span>, <span class="ruby-identifier">port</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">p_addr</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">p_port</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">p_user</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">p_pass</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">h</span> = <span class="ruby-constant">Proxy</span>(<span class="ruby-identifier">p_addr</span>, <span class="ruby-identifier">p_port</span>, <span class="ruby-identifier">p_user</span>, <span class="ruby-identifier">p_pass</span>).<span class="ruby-identifier">newobj</span>(<span class="ruby-identifier">address</span>, <span class="ruby-identifier">port</span>)
  <span class="ruby-identifier">h</span>.<span class="ruby-identifier">instance_eval</span> {
    <span class="ruby-ivar">@newimpl</span> = <span class="ruby-operator">::</span><span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">HTTP</span>.<span class="ruby-identifier">version_1_2?</span>
  }
  <span class="ruby-identifier">h</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- new-source -->
            
          </div>

          
          <div class="aliases">
            Also aliased as: <a href="HTTP.html#method-c-newobj">newobj</a>
          </div>
          

          
        </div><!-- new-method -->

      
        <div id="new-method" class="method-detail ">
          <a name="method-c-new"></a>

          
          <div class="method-heading">
            <span class="method-name">new</span><span
              class="method-args">(address, port = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Creates a new Net::HTTP object for the specified <tt>address</tt>. This
method does not open the TCP connection.</p>
            

            
            <div class="method-source-code" id="new-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 510</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">initialize</span>(<span class="ruby-identifier">address</span>, <span class="ruby-identifier">port</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-ivar">@address</span> = <span class="ruby-identifier">address</span>
  <span class="ruby-ivar">@port</span>    = (<span class="ruby-identifier">port</span> <span class="ruby-operator">||</span> <span class="ruby-constant">HTTP</span>.<span class="ruby-identifier">default_port</span>)
  <span class="ruby-ivar">@curr_http_version</span> = <span class="ruby-constant">HTTPVersion</span>
  <span class="ruby-ivar">@no_keepalive_server</span> = <span class="ruby-keyword">false</span>
  <span class="ruby-ivar">@close_on_empty_response</span> = <span class="ruby-keyword">false</span>
  <span class="ruby-ivar">@socket</span>  = <span class="ruby-keyword">nil</span>
  <span class="ruby-ivar">@started</span> = <span class="ruby-keyword">false</span>
  <span class="ruby-ivar">@open_timeout</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-ivar">@read_timeout</span> = <span class="ruby-value">60</span>
  <span class="ruby-ivar">@debug_output</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-ivar">@use_ssl</span> = <span class="ruby-keyword">false</span>
  <span class="ruby-ivar">@ssl_context</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-ivar">@enable_post_connection_check</span> = <span class="ruby-keyword">true</span>
  <span class="ruby-ivar">@compression</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-ivar">@sspi_enabled</span> = <span class="ruby-keyword">false</span>
  <span class="ruby-keyword">if</span> <span class="ruby-keyword">defined?</span>(<span class="ruby-constant">SSL_ATTRIBUTES</span>)
    <span class="ruby-constant">SSL_ATTRIBUTES</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">name</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">instance_variable_set</span> <span class="ruby-node">&quot;@#{name}&quot;</span>, <span class="ruby-keyword">nil</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- new-source -->
            
          </div>

          

          
        </div><!-- new-method -->

      
        <div id="newobj-method" class="method-detail method-alias">
          <a name="method-c-newobj"></a>

          
          <div class="method-heading">
            <span class="method-name">newobj</span><span
              class="method-args">(address, port = nil, p_addr = nil, p_port = nil, p_user = nil, p_pass = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
          </div>

          

          
          <div class="aliases">
            Alias for: <a href="HTTP.html#method-c-new">new</a>
          </div>
          
        </div><!-- newobj-method -->

      
        <div id="post_form-method" class="method-detail ">
          <a name="method-c-post_form"></a>

          
          <div class="method-heading">
            <span class="method-name">post_form</span><span
              class="method-args">(url, params)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Posts HTML form data to the <tt>URL</tt>. Form data must be represented as
a Hash of String to String, e.g:</p>

<pre>{ &quot;cmd&quot; =&gt; &quot;search&quot;, &quot;q&quot; =&gt; &quot;ruby&quot;, &quot;max&quot; =&gt; &quot;50&quot; }</pre>

<p>This method also does Basic Authentication iff <tt>URL</tt>.user exists.</p>

<p>Example:</p>

<pre>require 'net/http'
require 'uri'

HTTP.post_form URI.parse('http://www.example.com/search.cgi'),
               { &quot;q&quot; =&gt; &quot;ruby&quot;, &quot;max&quot; =&gt; &quot;50&quot; }</pre>
            

            
            <div class="method-source-code" id="post_form-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 414</span>
<span class="ruby-keyword">def</span> <span class="ruby-constant">HTTP</span>.<span class="ruby-identifier">post_form</span>(<span class="ruby-identifier">url</span>, <span class="ruby-identifier">params</span>)
  <span class="ruby-identifier">req</span> = <span class="ruby-constant">Post</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">url</span>.<span class="ruby-identifier">path</span>)
  <span class="ruby-identifier">req</span>.<span class="ruby-identifier">form_data</span> = <span class="ruby-identifier">params</span>
  <span class="ruby-identifier">req</span>.<span class="ruby-identifier">basic_auth</span> <span class="ruby-identifier">url</span>.<span class="ruby-identifier">user</span>, <span class="ruby-identifier">url</span>.<span class="ruby-identifier">password</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">url</span>.<span class="ruby-identifier">user</span>
  <span class="ruby-identifier">new</span>(<span class="ruby-identifier">url</span>.<span class="ruby-identifier">host</span>, <span class="ruby-identifier">url</span>.<span class="ruby-identifier">port</span>).<span class="ruby-identifier">start</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">http</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">http</span>.<span class="ruby-identifier">request</span>(<span class="ruby-identifier">req</span>)
  }
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- post_form-source -->
            
          </div>

          

          
        </div><!-- post_form-method -->

      
        <div id="proxy_class-3F-method" class="method-detail ">
          <a name="method-c-proxy_class-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">proxy_class?</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>returns true if self is a class which was created by HTTP::Proxy.</p>
            

            
            <div class="method-source-code" id="proxy_class-3F-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 756</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">proxy_class?</span>
  <span class="ruby-ivar">@is_proxy_class</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- proxy_class-3F-source -->
            
          </div>

          

          
        </div><!-- proxy_class-3F-method -->

      
        <div id="start-method" class="method-detail ">
          <a name="method-c-start"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">start(address, port, p_addr, p_port, p_user, p_pass, &block)</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">start(address, port=nil, p_addr=nil, p_port=nil, p_user=nil, p_pass=nil, opt, &block)</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>creates a new Net::HTTP object and opens its TCP connection and HTTP
session.</p>

<p>Argments are following:</p>
<table class="rdoc-list"><tr><td class="rdoc-term"><p><em>address</em> </p></td>
<td>
<p>hostname or IP address of the server</p>
</td></tr><tr><td class="rdoc-term"><p><em>port</em>    </p></td>
<td>
<p>port of the server</p>
</td></tr><tr><td class="rdoc-term"><p><em>p_addr</em>  </p></td>
<td>
<p>address of proxy</p>
</td></tr><tr><td class="rdoc-term"><p><em>p_port</em>  </p></td>
<td>
<p>port of proxy</p>
</td></tr><tr><td class="rdoc-term"><p><em>p_user</em>  </p></td>
<td>
<p>user of proxy</p>
</td></tr><tr><td class="rdoc-term"><p><em>p_pass</em>  </p></td>
<td>
<p>pass of proxy</p>
</td></tr><tr><td class="rdoc-term"><p><em>opt</em>     </p></td>
<td>
<p>optional hash</p>
</td></tr></table>

<p><em>opt</em> sets following values by its accessor. The keys are ca_file,
ca_path, cert, cert_store, ciphers, <a
href="HTTP.html#attribute-i-close_on_empty_response">close_on_empty_response</a>,
key, <a href="HTTP.html#attribute-i-open_timeout">open_timeout</a>, <a
href="HTTP.html#attribute-i-read_timeout">read_timeout</a>, ssl_timeout,
ssl_version, use_ssl, verify_callback, verify_depth and verify_mode. If you
set :use_ssl as true, you can use https and default value of verify_mode is
set as OpenSSL::SSL::VERIFY_PEER.</p>

<p>If the optional block is given, the newly created Net::HTTP object is
passed to it and closed when the block finishes.  In this case, the return
value of this method is the return value of the block.  If no block is
given, the return value of this method is the newly created Net::HTTP
object itself, and the caller is responsible for closing it upon
completion.</p>
            

            
            <div class="method-source-code" id="start-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 475</span>
<span class="ruby-keyword">def</span> <span class="ruby-constant">HTTP</span>.<span class="ruby-identifier">start</span>(<span class="ruby-identifier">address</span>, *<span class="ruby-identifier">arg</span>, &amp;<span class="ruby-identifier">block</span>) <span class="ruby-comment"># :yield: +http+</span>
  <span class="ruby-identifier">arg</span>.<span class="ruby-identifier">pop</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">opt</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">try_convert</span>(<span class="ruby-identifier">arg</span>[<span class="ruby-value">-1</span>])
  <span class="ruby-identifier">port</span>, <span class="ruby-identifier">p_addr</span>, <span class="ruby-identifier">p_port</span>, <span class="ruby-identifier">p_user</span>, <span class="ruby-identifier">p_pass</span> = *<span class="ruby-identifier">arg</span>
  <span class="ruby-identifier">port</span> = <span class="ruby-identifier">https_default_port</span> <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">port</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">opt</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">opt</span>[<span class="ruby-value">:use_ssl</span>]
  <span class="ruby-identifier">http</span> = <span class="ruby-identifier">new</span>(<span class="ruby-identifier">address</span>, <span class="ruby-identifier">port</span>, <span class="ruby-identifier">p_addr</span>, <span class="ruby-identifier">p_port</span>, <span class="ruby-identifier">p_user</span>, <span class="ruby-identifier">p_pass</span>)

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">opt</span>
    <span class="ruby-identifier">opt</span> = {<span class="ruby-identifier">verify_mode</span><span class="ruby-operator">:</span> <span class="ruby-constant">OpenSSL</span><span class="ruby-operator">::</span><span class="ruby-constant">SSL</span><span class="ruby-operator">::</span><span class="ruby-constant">VERIFY_PEER</span>}.<span class="ruby-identifier">update</span>(<span class="ruby-identifier">opt</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">opt</span>[<span class="ruby-value">:use_ssl</span>]
    <span class="ruby-identifier">http</span>.<span class="ruby-identifier">methods</span>.<span class="ruby-identifier">grep</span>(<span class="ruby-regexp">/\A(\w+)=\z/</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">meth</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">key</span> = <span class="ruby-node">$1</span>.<span class="ruby-identifier">to_sym</span>
      <span class="ruby-identifier">opt</span>.<span class="ruby-identifier">key?</span>(<span class="ruby-identifier">key</span>) <span class="ruby-keyword">or</span> <span class="ruby-keyword">next</span>
      <span class="ruby-identifier">http</span>.<span class="ruby-identifier">__send__</span>(<span class="ruby-identifier">meth</span>, <span class="ruby-identifier">opt</span>[<span class="ruby-identifier">key</span>])
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">http</span>.<span class="ruby-identifier">start</span>(&amp;<span class="ruby-identifier">block</span>)
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- start-source -->
            
          </div>

          

          
        </div><!-- start-method -->

      
        <div id="version_1_1-method" class="method-detail ">
          <a name="method-c-version_1_1"></a>

          
          <div class="method-heading">
            <span class="method-name">version_1_1</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Turns on net/http 1.1 (ruby 1.6) features. Defaults to OFF in ruby 1.8.</p>
            

            
            <div class="method-source-code" id="version_1_1-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 314</span>
<span class="ruby-keyword">def</span> <span class="ruby-constant">HTTP</span>.<span class="ruby-identifier">version_1_1</span>
  <span class="ruby-ivar">@newimpl</span> = <span class="ruby-keyword">false</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- version_1_1-source -->
            
          </div>

          

          
        </div><!-- version_1_1-method -->

      
        <div id="version_1_1-3F-method" class="method-detail ">
          <a name="method-c-version_1_1-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">version_1_1?</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>true if net/http is in version 1.1 compatible mode. Defaults to true.</p>
            

            
            <div class="method-source-code" id="version_1_1-3F-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 326</span>
<span class="ruby-keyword">def</span> <span class="ruby-constant">HTTP</span>.<span class="ruby-identifier">version_1_1?</span>
  <span class="ruby-keyword">not</span> <span class="ruby-ivar">@newimpl</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- version_1_1-3F-source -->
            
          </div>

          
          <div class="aliases">
            Also aliased as: <a href="HTTP.html#method-c-is_version_1_1-3F">is_version_1_1?</a>
          </div>
          

          
        </div><!-- version_1_1-3F-method -->

      
        <div id="version_1_2-method" class="method-detail ">
          <a name="method-c-version_1_2"></a>

          
          <div class="method-heading">
            <span class="method-name">version_1_2</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Turns on net/http 1.2 (ruby 1.8) features. Defaults to ON in ruby 1.8.</p>

<p>I strongly recommend to call this method always.</p>

<pre>require 'net/http'
Net::HTTP.version_1_2</pre>
            

            
            <div class="method-source-code" id="version_1_2-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 308</span>
<span class="ruby-keyword">def</span> <span class="ruby-constant">HTTP</span>.<span class="ruby-identifier">version_1_2</span>
  <span class="ruby-ivar">@newimpl</span> = <span class="ruby-keyword">true</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- version_1_2-source -->
            
          </div>

          

          
        </div><!-- version_1_2-method -->

      
        <div id="version_1_2-3F-method" class="method-detail ">
          <a name="method-c-version_1_2-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">version_1_2?</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>true if net/http is in version 1.2 mode. Defaults to true.</p>
            

            
            <div class="method-source-code" id="version_1_2-3F-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 320</span>
<span class="ruby-keyword">def</span> <span class="ruby-constant">HTTP</span>.<span class="ruby-identifier">version_1_2?</span>
  <span class="ruby-ivar">@newimpl</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- version_1_2-3F-source -->
            
          </div>

          
          <div class="aliases">
            Also aliased as: <a href="HTTP.html#method-c-is_version_1_2-3F">is_version_1_2?</a>
          </div>
          

          
        </div><!-- version_1_2-3F-method -->

      
      </div><!-- public-class-method-details -->
    
      <div id="public-instance-method-details" class="method-section section">
        <h3 class="section-header">Public Instance Methods</h3>

      
        <div id="active-3F-method" class="method-detail method-alias">
          <a name="method-i-active-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">active?</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
          </div>

          

          
          <div class="aliases">
            Alias for: <a href="HTTP.html#method-i-started-3F">started?</a>
          </div>
          
        </div><!-- active-3F-method -->

      
        <div id="copy-method" class="method-detail ">
          <a name="method-i-copy"></a>

          
          <div class="method-heading">
            <span class="method-name">copy</span><span
              class="method-args">(path, initheader = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Sends a COPY request to the <tt>path</tt> and gets a response, as an <a
href="HTTPResponse.html">HTTPResponse</a> object.</p>
            

            
            <div class="method-source-code" id="copy-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 1039</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">copy</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">request</span>(<span class="ruby-constant">Copy</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span>))
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- copy-source -->
            
          </div>

          

          
        </div><!-- copy-method -->

      
        <div id="delete-method" class="method-detail ">
          <a name="method-i-delete"></a>

          
          <div class="method-heading">
            <span class="method-name">delete</span><span
              class="method-args">(path, initheader = {'Depth' => 'Infinity'})</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Sends a DELETE request to the <tt>path</tt> and gets a response, as an <a
href="HTTPResponse.html">HTTPResponse</a> object.</p>
            

            
            <div class="method-source-code" id="delete-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 1027</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">delete</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span> = {<span class="ruby-string">'Depth'</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">'Infinity'</span>})
  <span class="ruby-identifier">request</span>(<span class="ruby-constant">Delete</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span>))
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- delete-source -->
            
          </div>

          

          
        </div><!-- delete-method -->

      
        <div id="finish-method" class="method-detail ">
          <a name="method-i-finish"></a>

          
          <div class="method-heading">
            <span class="method-name">finish</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Finishes HTTP session and closes TCP connection. Raises IOError if not
started.</p>
            

            
            <div class="method-source-code" id="finish-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 698</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">finish</span>
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">IOError</span>, <span class="ruby-string">'HTTP session not yet started'</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">started?</span>
  <span class="ruby-identifier">do_finish</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- finish-source -->
            
          </div>

          

          
        </div><!-- finish-method -->

      
        <div id="get-method" class="method-detail ">
          <a name="method-i-get"></a>

          
          <div class="method-heading">
            <span class="method-name">get</span><span
              class="method-args">(path, initheader = {}, dest = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Gets data from <tt>path</tt> on the connected-to host. <tt>initheader</tt>
must be a Hash like { ‘Accept’ =&gt; ‘<b>/</b>’, … }, and it defaults to an
empty hash. If <tt>initheader</tt> doesn’t have the key ‘accept-encoding’,
then a value of “gzip;q=1.0,deflate;q=0.6,identity;q=0.3” is used, so that
gzip compression is used in preference to deflate compression, which is
used in preference to no compression. Ruby doesn’t have libraries to
support the compress (Lempel-Ziv) compression, so that is not supported. 
The intent of this is to reduce bandwidth by default.   If this routine
sets up compression, then it does the decompression also, removing the
header as well to prevent confusion.  Otherwise it leaves the body as it
found it.</p>

<p>In version 1.1 (ruby 1.6), this method returns a pair of objects, a <a
href="HTTPResponse.html">Net::HTTPResponse</a> object and the entity body
string. In version 1.2 (ruby 1.8), this method returns a <a
href="HTTPResponse.html">Net::HTTPResponse</a> object.</p>

<p>If called with a block, yields each fragment of the entity body in turn as
a string as it is read from the socket.  Note that in this case, the
returned response object will <b>not</b> contain a (meaningful) body.</p>

<p><tt>dest</tt> argument is obsolete. It still works but you must not use it.</p>

<p>In version 1.1, this method might raise an exception for 3xx (redirect). In
this case you can get a <a href="HTTPResponse.html">HTTPResponse</a> object
by “anException.response”.</p>

<p>In version 1.2, this method never raises exception.</p>

<pre># version 1.1 (bundled with Ruby 1.6)
response, body = http.get('/index.html')

# version 1.2 (bundled with Ruby 1.8 or later)
response = http.get('/index.html')

# using block
File.open('result.txt', 'w') {|f|
  http.get('/~foo/') do |str|
    f.write str
  end
}</pre>
            

            
            <div class="method-source-code" id="get-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 878</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">get</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span> = {}, <span class="ruby-identifier">dest</span> = <span class="ruby-keyword">nil</span>, &amp;<span class="ruby-identifier">block</span>) <span class="ruby-comment"># :yield: +body_segment+</span>
  <span class="ruby-identifier">res</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">if</span> <span class="ruby-constant">HAVE_ZLIB</span>
    <span class="ruby-keyword">unless</span>  <span class="ruby-identifier">initheader</span>.<span class="ruby-identifier">keys</span>.<span class="ruby-identifier">any?</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">k</span><span class="ruby-operator">|</span> <span class="ruby-identifier">k</span>.<span class="ruby-identifier">downcase</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;accept-encoding&quot;</span>}
      <span class="ruby-identifier">initheader</span> = <span class="ruby-identifier">initheader</span>.<span class="ruby-identifier">merge</span>({
        <span class="ruby-string">&quot;accept-encoding&quot;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&quot;gzip;q=1.0,deflate;q=0.6,identity;q=0.3&quot;</span>
      })
      <span class="ruby-ivar">@compression</span> = <span class="ruby-keyword">true</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">request</span>(<span class="ruby-constant">Get</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span>)) {<span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">r</span>.<span class="ruby-identifier">key?</span>(<span class="ruby-string">&quot;content-encoding&quot;</span>) <span class="ruby-keyword">and</span> <span class="ruby-ivar">@compression</span>
      <span class="ruby-ivar">@compression</span> = <span class="ruby-keyword">nil</span> <span class="ruby-comment"># Clear it till next set.</span>
      <span class="ruby-identifier">the_body</span> = <span class="ruby-identifier">r</span>.<span class="ruby-identifier">read_body</span> <span class="ruby-identifier">dest</span>, &amp;<span class="ruby-identifier">block</span>
      <span class="ruby-keyword">case</span> <span class="ruby-identifier">r</span>[<span class="ruby-string">&quot;content-encoding&quot;</span>]
      <span class="ruby-keyword">when</span> <span class="ruby-string">&quot;gzip&quot;</span>
        <span class="ruby-identifier">r</span>.<span class="ruby-identifier">body</span>= <span class="ruby-constant">Zlib</span><span class="ruby-operator">::</span><span class="ruby-constant">GzipReader</span>.<span class="ruby-identifier">new</span>(<span class="ruby-constant">StringIO</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">the_body</span>), <span class="ruby-identifier">encoding</span><span class="ruby-operator">:</span> <span class="ruby-string">&quot;ASCII-8BIT&quot;</span>).<span class="ruby-identifier">read</span>
        <span class="ruby-identifier">r</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-string">&quot;content-encoding&quot;</span>)
      <span class="ruby-keyword">when</span> <span class="ruby-string">&quot;deflate&quot;</span>
        <span class="ruby-identifier">r</span>.<span class="ruby-identifier">body</span>= <span class="ruby-constant">Zlib</span><span class="ruby-operator">::</span><span class="ruby-constant">Inflate</span>.<span class="ruby-identifier">inflate</span>(<span class="ruby-identifier">the_body</span>);
        <span class="ruby-identifier">r</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-string">&quot;content-encoding&quot;</span>)
      <span class="ruby-keyword">when</span> <span class="ruby-string">&quot;identity&quot;</span>
        ; <span class="ruby-comment"># nothing needed</span>
      <span class="ruby-keyword">else</span>
        ; <span class="ruby-comment"># Don't do anything dramatic, unless we need to later</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">r</span>.<span class="ruby-identifier">read_body</span> <span class="ruby-identifier">dest</span>, &amp;<span class="ruby-identifier">block</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">res</span> = <span class="ruby-identifier">r</span>
  }
  <span class="ruby-keyword">unless</span> <span class="ruby-ivar">@newimpl</span>
    <span class="ruby-identifier">res</span>.<span class="ruby-identifier">value</span>
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">res</span>, <span class="ruby-identifier">res</span>.<span class="ruby-identifier">body</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">res</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- get-source -->
            
          </div>

          

          
        </div><!-- get-method -->

      
        <div id="get2-method" class="method-detail method-alias">
          <a name="method-i-get2"></a>

          
          <div class="method-heading">
            <span class="method-name">get2</span><span
              class="method-args">(path, initheader = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
          </div>

          

          
          <div class="aliases">
            Alias for: <a href="HTTP.html#method-i-request_get">request_get</a>
          </div>
          
        </div><!-- get2-method -->

      
        <div id="head-method" class="method-detail ">
          <a name="method-i-head"></a>

          
          <div class="method-heading">
            <span class="method-name">head</span><span
              class="method-args">(path, initheader = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Gets only the header from <tt>path</tt> on the connected-to host.
<tt>header</tt> is a Hash like { ‘Accept’ =&gt; ‘<b>/</b>’, … }.</p>

<p>This method returns a <a href="HTTPResponse.html">Net::HTTPResponse</a>
object.</p>

<p>In version 1.1, this method might raise an exception for 3xx (redirect). On
the case you can get a <a href="HTTPResponse.html">HTTPResponse</a> object
by “anException.response”. In version 1.2, this method never raises an
exception.</p>

<pre>response = nil
Net::HTTP.start('some.www.server', 80) {|http|
  response = http.head('/index.html')
}
p response['content-type']</pre>
            

            
            <div class="method-source-code" id="head-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 933</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">head</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">res</span> = <span class="ruby-identifier">request</span>(<span class="ruby-constant">Head</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span>))
  <span class="ruby-identifier">res</span>.<span class="ruby-identifier">value</span> <span class="ruby-keyword">unless</span> <span class="ruby-ivar">@newimpl</span>
  <span class="ruby-identifier">res</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- head-source -->
            
          </div>

          

          
        </div><!-- head-method -->

      
        <div id="head2-method" class="method-detail method-alias">
          <a name="method-i-head2"></a>

          
          <div class="method-heading">
            <span class="method-name">head2</span><span
              class="method-args">(path, initheader = nil, &block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
          </div>

          

          
          <div class="aliases">
            Alias for: <a href="HTTP.html#method-i-request_head">request_head</a>
          </div>
          
        </div><!-- head2-method -->

      
        <div id="inspect-method" class="method-detail ">
          <a name="method-i-inspect"></a>

          
          <div class="method-heading">
            <span class="method-name">inspect</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
            <div class="method-source-code" id="inspect-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 533</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">inspect</span>
  <span class="ruby-node">&quot;#&lt;#{self.class} #{@address}:#{@port} open=#{started?}&gt;&quot;</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- inspect-source -->
            
          </div>

          

          
        </div><!-- inspect-method -->

      
        <div id="lock-method" class="method-detail ">
          <a name="method-i-lock"></a>

          
          <div class="method-heading">
            <span class="method-name">lock</span><span
              class="method-args">(path, body, initheader = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Sends a LOCK request to the <tt>path</tt> and gets a response, as an <a
href="HTTPResponse.html">HTTPResponse</a> object.</p>
            

            
            <div class="method-source-code" id="lock-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 1003</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">lock</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">body</span>, <span class="ruby-identifier">initheader</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">request</span>(<span class="ruby-constant">Lock</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span>), <span class="ruby-identifier">body</span>)
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- lock-source -->
            
          </div>

          

          
        </div><!-- lock-method -->

      
        <div id="mkcol-method" class="method-detail ">
          <a name="method-i-mkcol"></a>

          
          <div class="method-heading">
            <span class="method-name">mkcol</span><span
              class="method-args">(path, body = nil, initheader = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Sends a MKCOL request to the <tt>path</tt> and gets a response, as an <a
href="HTTPResponse.html">HTTPResponse</a> object.</p>
            

            
            <div class="method-source-code" id="mkcol-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 1045</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">mkcol</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">body</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">initheader</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">request</span>(<span class="ruby-constant">Mkcol</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span>), <span class="ruby-identifier">body</span>)
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- mkcol-source -->
            
          </div>

          

          
        </div><!-- mkcol-method -->

      
        <div id="move-method" class="method-detail ">
          <a name="method-i-move"></a>

          
          <div class="method-heading">
            <span class="method-name">move</span><span
              class="method-args">(path, initheader = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Sends a MOVE request to the <tt>path</tt> and gets a response, as an <a
href="HTTPResponse.html">HTTPResponse</a> object.</p>
            

            
            <div class="method-source-code" id="move-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 1033</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">move</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">request</span>(<span class="ruby-constant">Move</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span>))
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- move-source -->
            
          </div>

          

          
        </div><!-- move-method -->

      
        <div id="options-method" class="method-detail ">
          <a name="method-i-options"></a>

          
          <div class="method-heading">
            <span class="method-name">options</span><span
              class="method-args">(path, initheader = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Sends a OPTIONS request to the <tt>path</tt> and gets a response, as an <a
href="HTTPResponse.html">HTTPResponse</a> object.</p>
            

            
            <div class="method-source-code" id="options-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 1015</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">options</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">request</span>(<span class="ruby-constant">Options</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span>))
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- options-source -->
            
          </div>

          

          
        </div><!-- options-method -->

      
        <div id="peer_cert-method" class="method-detail ">
          <a name="method-i-peer_cert"></a>

          
          <div class="method-heading">
            <span class="method-name">peer_cert</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>return the X.509 certificates the server presented.</p>
            

            
            <div class="method-source-code" id="peer_cert-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 606</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">peer_cert</span>
  <span class="ruby-keyword">if</span> <span class="ruby-keyword">not</span> <span class="ruby-identifier">use_ssl?</span> <span class="ruby-keyword">or</span> <span class="ruby-keyword">not</span> <span class="ruby-ivar">@socket</span>
    <span class="ruby-keyword">return</span> <span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-ivar">@socket</span>.<span class="ruby-identifier">io</span>.<span class="ruby-identifier">peer_cert</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- peer_cert-source -->
            
          </div>

          

          
        </div><!-- peer_cert-method -->

      
        <div id="post-method" class="method-detail ">
          <a name="method-i-post"></a>

          
          <div class="method-heading">
            <span class="method-name">post</span><span
              class="method-args">(path, data, initheader = nil, dest = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Posts <tt>data</tt> (must be a String) to <tt>path</tt>. <tt>header</tt>
must be a Hash like { ‘Accept’ =&gt; ‘<b>/</b>’, … }.</p>

<p>In version 1.1 (ruby 1.6), this method returns a pair of objects, a <a
href="HTTPResponse.html">Net::HTTPResponse</a> object and an entity body
string. In version 1.2 (ruby 1.8), this method returns a <a
href="HTTPResponse.html">Net::HTTPResponse</a> object.</p>

<p>If called with a block, yields each fragment of the entity body in turn as
a string as it are read from the socket.  Note that in this case, the
returned response object will <b>not</b> contain a (meaningful) body.</p>

<p><tt>dest</tt> argument is obsolete. It still works but you must not use it.</p>

<p>In version 1.1, this method might raise an exception for 3xx (redirect). In
this case you can get an <a href="HTTPResponse.html">HTTPResponse</a>
object by “anException.response”. In version 1.2, this method never raises
exception.</p>

<pre># version 1.1
response, body = http.post('/cgi-bin/search.rb', 'query=foo')

# version 1.2
response = http.post('/cgi-bin/search.rb', 'query=foo')

# using block
File.open('result.txt', 'w') {|f|
  http.post('/cgi-bin/search.rb', 'query=foo') do |str|
    f.write str
  end
}</pre>

<p>You should set Content-Type: header field for POST. If no Content-Type:
field given, this method uses “application/x-www-form-urlencoded” by
default.</p>
            

            
            <div class="method-source-code" id="post-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 976</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">post</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">data</span>, <span class="ruby-identifier">initheader</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">dest</span> = <span class="ruby-keyword">nil</span>, &amp;<span class="ruby-identifier">block</span>) <span class="ruby-comment"># :yield: +body_segment+</span>
  <span class="ruby-identifier">res</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-identifier">request</span>(<span class="ruby-constant">Post</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span>), <span class="ruby-identifier">data</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">r</span>.<span class="ruby-identifier">read_body</span> <span class="ruby-identifier">dest</span>, &amp;<span class="ruby-identifier">block</span>
    <span class="ruby-identifier">res</span> = <span class="ruby-identifier">r</span>
  }
  <span class="ruby-keyword">unless</span> <span class="ruby-ivar">@newimpl</span>
    <span class="ruby-identifier">res</span>.<span class="ruby-identifier">value</span>
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">res</span>, <span class="ruby-identifier">res</span>.<span class="ruby-identifier">body</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">res</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- post-source -->
            
          </div>

          

          
        </div><!-- post-method -->

      
        <div id="post2-method" class="method-detail method-alias">
          <a name="method-i-post2"></a>

          
          <div class="method-heading">
            <span class="method-name">post2</span><span
              class="method-args">(path, data, initheader = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
          </div>

          

          
          <div class="aliases">
            Alias for: <a href="HTTP.html#method-i-request_post">request_post</a>
          </div>
          
        </div><!-- post2-method -->

      
        <div id="propfind-method" class="method-detail ">
          <a name="method-i-propfind"></a>

          
          <div class="method-heading">
            <span class="method-name">propfind</span><span
              class="method-args">(path, body = nil, initheader = {'Depth' => '0'})</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Sends a PROPFIND request to the <tt>path</tt> and gets a response, as an <a
href="HTTPResponse.html">HTTPResponse</a> object.</p>
            

            
            <div class="method-source-code" id="propfind-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 1021</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">propfind</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">body</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">initheader</span> = {<span class="ruby-string">'Depth'</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">'0'</span>})
  <span class="ruby-identifier">request</span>(<span class="ruby-constant">Propfind</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span>), <span class="ruby-identifier">body</span>)
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- propfind-source -->
            
          </div>

          

          
        </div><!-- propfind-method -->

      
        <div id="proppatch-method" class="method-detail ">
          <a name="method-i-proppatch"></a>

          
          <div class="method-heading">
            <span class="method-name">proppatch</span><span
              class="method-args">(path, body, initheader = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Sends a PROPPATCH request to the <tt>path</tt> and gets a response, as an
<a href="HTTPResponse.html">HTTPResponse</a> object.</p>
            

            
            <div class="method-source-code" id="proppatch-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 997</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">proppatch</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">body</span>, <span class="ruby-identifier">initheader</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">request</span>(<span class="ruby-constant">Proppatch</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span>), <span class="ruby-identifier">body</span>)
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- proppatch-source -->
            
          </div>

          

          
        </div><!-- proppatch-method -->

      
        <div id="proxy-3F-method" class="method-detail ">
          <a name="method-i-proxy-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">proxy?</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>True if self is a HTTP proxy class.</p>
            

            
            <div class="method-source-code" id="proxy-3F-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 767</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">proxy?</span>
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">proxy_class?</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- proxy-3F-source -->
            
          </div>

          

          
        </div><!-- proxy-3F-method -->

      
        <div id="proxy_address-method" class="method-detail ">
          <a name="method-i-proxy_address"></a>

          
          <div class="method-heading">
            <span class="method-name">proxy_address</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Address of proxy host. If self does not use a proxy, nil.</p>
            

            
            <div class="method-source-code" id="proxy_address-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 772</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">proxy_address</span>
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">proxy_address</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- proxy_address-source -->
            
          </div>

          
          <div class="aliases">
            Also aliased as: <a href="HTTP.html#method-i-proxyaddr">proxyaddr</a>
          </div>
          

          
        </div><!-- proxy_address-method -->

      
        <div id="proxy_pass-method" class="method-detail ">
          <a name="method-i-proxy_pass"></a>

          
          <div class="method-heading">
            <span class="method-name">proxy_pass</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>User password for accessing proxy. If self does not use a proxy, nil.</p>
            

            
            <div class="method-source-code" id="proxy_pass-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 787</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">proxy_pass</span>
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">proxy_pass</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- proxy_pass-source -->
            
          </div>

          

          
        </div><!-- proxy_pass-method -->

      
        <div id="proxy_port-method" class="method-detail ">
          <a name="method-i-proxy_port"></a>

          
          <div class="method-heading">
            <span class="method-name">proxy_port</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Port number of proxy host. If self does not use a proxy, nil.</p>
            

            
            <div class="method-source-code" id="proxy_port-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 777</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">proxy_port</span>
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">proxy_port</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- proxy_port-source -->
            
          </div>

          
          <div class="aliases">
            Also aliased as: <a href="HTTP.html#method-i-proxyport">proxyport</a>
          </div>
          

          
        </div><!-- proxy_port-method -->

      
        <div id="proxy_user-method" class="method-detail ">
          <a name="method-i-proxy_user"></a>

          
          <div class="method-heading">
            <span class="method-name">proxy_user</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>User name for accessing proxy. If self does not use a proxy, nil.</p>
            

            
            <div class="method-source-code" id="proxy_user-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 782</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">proxy_user</span>
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">proxy_user</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- proxy_user-source -->
            
          </div>

          

          
        </div><!-- proxy_user-method -->

      
        <div id="proxyaddr-method" class="method-detail method-alias">
          <a name="method-i-proxyaddr"></a>

          
          <div class="method-heading">
            <span class="method-name">proxyaddr</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
          </div>

          

          
          <div class="aliases">
            Alias for: <a href="HTTP.html#method-i-proxy_address">proxy_address</a>
          </div>
          
        </div><!-- proxyaddr-method -->

      
        <div id="proxyport-method" class="method-detail method-alias">
          <a name="method-i-proxyport"></a>

          
          <div class="method-heading">
            <span class="method-name">proxyport</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
          </div>

          

          
          <div class="aliases">
            Alias for: <a href="HTTP.html#method-i-proxy_port">proxy_port</a>
          </div>
          
        </div><!-- proxyport-method -->

      
        <div id="read_timeout-3D-method" class="method-detail ">
          <a name="method-i-read_timeout-3D"></a>

          
          <div class="method-heading">
            <span class="method-name">read_timeout=</span><span
              class="method-args">(sec)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Setter for the <a
href="HTTP.html#attribute-i-read_timeout">read_timeout</a> attribute.</p>
            

            
            <div class="method-source-code" id="read_timeout-3D-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 568</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">read_timeout=</span>(<span class="ruby-identifier">sec</span>)
  <span class="ruby-ivar">@socket</span>.<span class="ruby-identifier">read_timeout</span> = <span class="ruby-identifier">sec</span> <span class="ruby-keyword">if</span> <span class="ruby-ivar">@socket</span>
  <span class="ruby-ivar">@read_timeout</span> = <span class="ruby-identifier">sec</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- read_timeout-3D-source -->
            
          </div>

          

          
        </div><!-- read_timeout-3D-method -->

      
        <div id="request-method" class="method-detail ">
          <a name="method-i-request"></a>

          
          <div class="method-heading">
            <span class="method-name">request</span><span
              class="method-args">(req, body = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Sends an <a href="HTTPRequest.html">HTTPRequest</a> object REQUEST to the
HTTP server. This method also sends DATA string if REQUEST is a post/put
request. Giving DATA for get/head request causes ArgumentError.</p>

<p>When called with a block, yields an <a
href="HTTPResponse.html">HTTPResponse</a> object. The body of this response
will not have been read yet; the caller can process it using <a
href="HTTPResponse.html#method-i-read_body">HTTPResponse#read_body</a>, if
desired.</p>

<p>Returns a <a href="HTTPResponse.html">HTTPResponse</a> object.</p>

<p>This method never raises Net::* exceptions.</p>
            

            
            <div class="method-source-code" id="request-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 1166</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">request</span>(<span class="ruby-identifier">req</span>, <span class="ruby-identifier">body</span> = <span class="ruby-keyword">nil</span>, &amp;<span class="ruby-identifier">block</span>)  <span class="ruby-comment"># :yield: +response+</span>
  <span class="ruby-keyword">unless</span> <span class="ruby-identifier">started?</span>
    <span class="ruby-identifier">start</span> {
      <span class="ruby-identifier">req</span>[<span class="ruby-string">'connection'</span>] <span class="ruby-operator">||=</span> <span class="ruby-string">'close'</span>
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">request</span>(<span class="ruby-identifier">req</span>, <span class="ruby-identifier">body</span>, &amp;<span class="ruby-identifier">block</span>)
    }
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">proxy_user</span>()
    <span class="ruby-identifier">req</span>.<span class="ruby-identifier">proxy_basic_auth</span> <span class="ruby-identifier">proxy_user</span>(), <span class="ruby-identifier">proxy_pass</span>() <span class="ruby-keyword">unless</span> <span class="ruby-identifier">use_ssl?</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">req</span>.<span class="ruby-identifier">set_body_internal</span> <span class="ruby-identifier">body</span>
  <span class="ruby-identifier">res</span> = <span class="ruby-identifier">transport_request</span>(<span class="ruby-identifier">req</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">sspi_auth?</span>(<span class="ruby-identifier">res</span>)
    <span class="ruby-identifier">sspi_auth</span>(<span class="ruby-identifier">req</span>)
    <span class="ruby-identifier">res</span> = <span class="ruby-identifier">transport_request</span>(<span class="ruby-identifier">req</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">res</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- request-source -->
            
          </div>

          

          
        </div><!-- request-method -->

      
        <div id="request_get-method" class="method-detail ">
          <a name="method-i-request_get"></a>

          
          <div class="method-heading">
            <span class="method-name">request_get</span><span
              class="method-args">(path, initheader = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Sends a GET request to the <tt>path</tt> and gets a response, as an <a
href="HTTPResponse.html">HTTPResponse</a> object.</p>

<p>When called with a block, yields an <a
href="HTTPResponse.html">HTTPResponse</a> object. The body of this response
will not have been read yet; the caller can process it using <a
href="HTTPResponse.html#method-i-read_body">HTTPResponse#read_body</a>, if
desired.</p>

<p>Returns the response.</p>

<p>This method never raises Net::* exceptions.</p>

<pre>response = http.request_get('/index.html')
# The entity body is already read here.
p response['content-type']
puts response.body

# using block
http.request_get('/index.html') {|response|
  p response['content-type']
  response.read_body do |str|   # read body now
    print str
  end
}</pre>
            

            
            <div class="method-source-code" id="request_get-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 1080</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">request_get</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span> = <span class="ruby-keyword">nil</span>, &amp;<span class="ruby-identifier">block</span>) <span class="ruby-comment"># :yield: +response+</span>
  <span class="ruby-identifier">request</span>(<span class="ruby-constant">Get</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span>), &amp;<span class="ruby-identifier">block</span>)
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- request_get-source -->
            
          </div>

          
          <div class="aliases">
            Also aliased as: <a href="HTTP.html#method-i-get2">get2</a>
          </div>
          

          
        </div><!-- request_get-method -->

      
        <div id="request_head-method" class="method-detail ">
          <a name="method-i-request_head"></a>

          
          <div class="method-heading">
            <span class="method-name">request_head</span><span
              class="method-args">(path, initheader = nil, &block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Sends a HEAD request to the <tt>path</tt> and gets a response, as an <a
href="HTTPResponse.html">HTTPResponse</a> object.</p>

<p>Returns the response.</p>

<p>This method never raises Net::* exceptions.</p>

<pre>response = http.request_head('/index.html')
p response['content-type']</pre>
            

            
            <div class="method-source-code" id="request_head-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 1094</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">request_head</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span> = <span class="ruby-keyword">nil</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">request</span>(<span class="ruby-constant">Head</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span>), &amp;<span class="ruby-identifier">block</span>)
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- request_head-source -->
            
          </div>

          
          <div class="aliases">
            Also aliased as: <a href="HTTP.html#method-i-head2">head2</a>
          </div>
          

          
        </div><!-- request_head-method -->

      
        <div id="request_post-method" class="method-detail ">
          <a name="method-i-request_post"></a>

          
          <div class="method-heading">
            <span class="method-name">request_post</span><span
              class="method-args">(path, data, initheader = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Sends a POST request to the <tt>path</tt> and gets a response, as an <a
href="HTTPResponse.html">HTTPResponse</a> object.</p>

<p>When called with a block, yields an <a
href="HTTPResponse.html">HTTPResponse</a> object. The body of this response
will not have been read yet; the caller can process it using <a
href="HTTPResponse.html#method-i-read_body">HTTPResponse#read_body</a>, if
desired.</p>

<p>Returns the response.</p>

<p>This method never raises Net::* exceptions.</p>

<pre># example
response = http.request_post('/cgi-bin/nice.rb', 'datadatadata...')
p response.status
puts response.body          # body is already read

# using block
http.request_post('/cgi-bin/nice.rb', 'datadatadata...') {|response|
  p response.status
  p response['content-type']
  response.read_body do |str|   # read body now
    print str
  end
}</pre>
            

            
            <div class="method-source-code" id="request_post-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 1124</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">request_post</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">data</span>, <span class="ruby-identifier">initheader</span> = <span class="ruby-keyword">nil</span>, &amp;<span class="ruby-identifier">block</span>) <span class="ruby-comment"># :yield: +response+</span>
  <span class="ruby-identifier">request</span> <span class="ruby-constant">Post</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span>), <span class="ruby-identifier">data</span>, &amp;<span class="ruby-identifier">block</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- request_post-source -->
            
          </div>

          
          <div class="aliases">
            Also aliased as: <a href="HTTP.html#method-i-post2">post2</a>
          </div>
          

          
        </div><!-- request_post-method -->

      
        <div id="send_request-method" class="method-detail ">
          <a name="method-i-send_request"></a>

          
          <div class="method-heading">
            <span class="method-name">send_request</span><span
              class="method-args">(name, path, data = nil, header = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Sends an HTTP request to the HTTP server. This method also sends DATA
string if DATA is given.</p>

<p>Returns a <a href="HTTPResponse.html">HTTPResponse</a> object.</p>

<p>This method never raises Net::* exceptions.</p>

<pre>response = http.send_request('GET', '/index.html')
puts response.body</pre>
            

            
            <div class="method-source-code" id="send_request-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 1148</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">send_request</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">path</span>, <span class="ruby-identifier">data</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">header</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">r</span> = <span class="ruby-constant">HTTPGenericRequest</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">name</span>,(<span class="ruby-identifier">data</span> <span class="ruby-operator">?</span> <span class="ruby-keyword">true</span> <span class="ruby-operator">:</span> <span class="ruby-keyword">false</span>),<span class="ruby-keyword">true</span>,<span class="ruby-identifier">path</span>,<span class="ruby-identifier">header</span>)
  <span class="ruby-identifier">request</span> <span class="ruby-identifier">r</span>, <span class="ruby-identifier">data</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- send_request-source -->
            
          </div>

          

          
        </div><!-- send_request-method -->

      
        <div id="set_debug_output-method" class="method-detail ">
          <a name="method-i-set_debug_output"></a>

          
          <div class="method-heading">
            <span class="method-name">set_debug_output</span><span
              class="method-args">(output)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p><b>WARNING</b> This method causes serious security hole. Never use this
method in production code.</p>

<p>Set an output stream for debugging.</p>

<pre>http = Net::HTTP.new
http.set_debug_output $stderr
http.start { .... }</pre>
            

            
            <div class="method-source-code" id="set_debug_output-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 546</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">set_debug_output</span>(<span class="ruby-identifier">output</span>)
  <span class="ruby-identifier">warn</span> <span class="ruby-string">'Net::HTTP#set_debug_output called after HTTP started'</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">started?</span>
  <span class="ruby-ivar">@debug_output</span> = <span class="ruby-identifier">output</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- set_debug_output-source -->
            
          </div>

          

          
        </div><!-- set_debug_output-method -->

      
        <div id="start-method" class="method-detail ">
          <a name="method-i-start"></a>

          
          <div class="method-heading">
            <span class="method-name">start</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Opens TCP connection and HTTP session.</p>

<p>When this method is called with block, gives a HTTP object to the block and
closes the TCP connection / HTTP session after the block executed.</p>

<p>When called with a block, returns the return value of the block; otherwise,
returns self.</p>
            

            
            <div class="method-source-code" id="start-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 622</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">start</span>  <span class="ruby-comment"># :yield: http</span>
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">IOError</span>, <span class="ruby-string">'HTTP session already opened'</span> <span class="ruby-keyword">if</span> <span class="ruby-ivar">@started</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>
    <span class="ruby-keyword">begin</span>
      <span class="ruby-identifier">do_start</span>
      <span class="ruby-keyword">return</span> <span class="ruby-keyword">yield</span>(<span class="ruby-keyword">self</span>)
    <span class="ruby-keyword">ensure</span>
      <span class="ruby-identifier">do_finish</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">do_start</span>
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- start-source -->
            
          </div>

          

          
        </div><!-- start-method -->

      
        <div id="started-3F-method" class="method-detail ">
          <a name="method-i-started-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">started?</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>returns true if the HTTP session is started.</p>
            

            
            <div class="method-source-code" id="started-3F-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 574</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">started?</span>
  <span class="ruby-ivar">@started</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- started-3F-source -->
            
          </div>

          
          <div class="aliases">
            Also aliased as: <a href="HTTP.html#method-i-active-3F">active?</a>
          </div>
          

          
        </div><!-- started-3F-method -->

      
        <div id="trace-method" class="method-detail ">
          <a name="method-i-trace"></a>

          
          <div class="method-heading">
            <span class="method-name">trace</span><span
              class="method-args">(path, initheader = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Sends a TRACE request to the <tt>path</tt> and gets a response, as an <a
href="HTTPResponse.html">HTTPResponse</a> object.</p>
            

            
            <div class="method-source-code" id="trace-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 1051</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">trace</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">request</span>(<span class="ruby-constant">Trace</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span>))
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- trace-source -->
            
          </div>

          

          
        </div><!-- trace-method -->

      
        <div id="unlock-method" class="method-detail ">
          <a name="method-i-unlock"></a>

          
          <div class="method-heading">
            <span class="method-name">unlock</span><span
              class="method-args">(path, body, initheader = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Sends a UNLOCK request to the <tt>path</tt> and gets a response, as an <a
href="HTTPResponse.html">HTTPResponse</a> object.</p>
            

            
            <div class="method-source-code" id="unlock-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 1009</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">unlock</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">body</span>, <span class="ruby-identifier">initheader</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">request</span>(<span class="ruby-constant">Unlock</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span>), <span class="ruby-identifier">body</span>)
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- unlock-source -->
            
          </div>

          

          
        </div><!-- unlock-method -->

      
        <div id="use_ssl-3D-method" class="method-detail ">
          <a name="method-i-use_ssl-3D"></a>

          
          <div class="method-heading">
            <span class="method-name">use_ssl=</span><span
              class="method-args">(flag)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Turn on/off SSL. This flag must be set before starting session. If you
change use_ssl value after session started, a Net::HTTP object raises
IOError.</p>
            

            
            <div class="method-source-code" id="use_ssl-3D-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 591</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">use_ssl=</span>(<span class="ruby-identifier">flag</span>)
  <span class="ruby-identifier">flag</span> = (<span class="ruby-identifier">flag</span> <span class="ruby-operator">?</span> <span class="ruby-keyword">true</span> <span class="ruby-operator">:</span> <span class="ruby-keyword">false</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">started?</span> <span class="ruby-keyword">and</span> <span class="ruby-ivar">@use_ssl</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">flag</span>
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">IOError</span>, <span class="ruby-string">&quot;use_ssl value changed, but session already started&quot;</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-ivar">@use_ssl</span> = <span class="ruby-identifier">flag</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- use_ssl-3D-source -->
            
          </div>

          

          
        </div><!-- use_ssl-3D-method -->

      
        <div id="use_ssl-3F-method" class="method-detail ">
          <a name="method-i-use_ssl-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">use_ssl?</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>returns true if use SSL/TLS with HTTP.</p>
            

            
            <div class="method-source-code" id="use_ssl-3F-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 583</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">use_ssl?</span>
  <span class="ruby-ivar">@use_ssl</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- use_ssl-3F-source -->
            
          </div>

          

          
        </div><!-- use_ssl-3F-method -->

      
      </div><!-- public-instance-method-details -->
    
    </div><!-- 5Buntitled-5D -->
  
 <div class='info'>
  <p>Commenting is here to help enhance the documentation.  For example, sample code, or clarification of the documentation.</p>
  <p>If you have questions about Ruby or the documentation, please post to one of the <a href='http://www.ruby-lang.org/en/community/mailing-lists/'>Ruby mailing lists</a>.  You will get better, faster, help that way.</p>
  <p>If you wish to post a correction of the docs, please do so, but also <a href='http://bugs.ruby-lang.org/projects/ruby/wiki/HowtoReport' >file bug report</a> so that it can be corrected for the next release. Thank you.</p>
  </div>

  </div><!-- documentation -->
 
  <div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    // var disqus_shortname = 'rubydocbeta'; // required 
    var disqus_shortname = 'ruby-doc'; // required 
    
    var disqus_developer = true; // DEBUGGERY
    


    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>

<div class='grids wrapper' id="footer">
  <p><small>This page was generated for Ruby 1.9.2</small></p> 
  
   <p> <a href="http://www.ruby-doc.org">Ruby-doc.org</a> is provided by <a href="http://www.jamesbritt.com">James Britt</a> and <a href="http://www.neurogami.com">Neurogami</a>. <a href="http://www.neurogami.com">Maximum R+D</a>.  </p>
 
    <p><small>Generated with the <a href="http://neurogami.com/code/">Ruby-doc Rdoc Generator</a> 0.9.5</small>.</p>
  </div>

</div>

<script type="text/javascript">
var _uacct = "UA-335317-2";
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try{ 
var pageTracker = _gat._getTracker(_uacct);
pageTracker._trackPageview();
} catch(err) {} 
</script>
</body>
</html>

